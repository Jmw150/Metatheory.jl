<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rules and Theories · Metatheory.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Metatheory.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Metatheory.jl</a></li><li class="is-active"><a class="tocitem" href>Rules and Theories</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Rule-Syntax-for-Classical-Rewriting"><span>Rule Syntax for Classical Rewriting</span></a></li><li class="toplevel"><a class="tocitem" href="#Rule-Syntax-for-EGraphs-Rewriting"><span>Rule Syntax for EGraphs Rewriting</span></a></li><li><a class="tocitem" href="#Theories-are-Collections-and-Composable"><span>Theories are Collections and Composable</span></a></li><li><a class="tocitem" href="#Type-Assertions-and-Dynamic-Rules"><span>Type Assertions and Dynamic Rules</span></a></li><li><a class="tocitem" href="#Escaping"><span>Escaping</span></a></li><li><a class="tocitem" href="#Patterns"><span>Patterns</span></a></li><li><a class="tocitem" href="#Rules"><span>Rules</span></a></li></ul></li><li><a class="tocitem" href="../egraphs/">EGraphs and Equality Saturation</a></li><li><a class="tocitem" href="../analysis/">E-Graph Analysis</a></li><li><a class="tocitem" href="../extraction/">Extracting from an E-Graph</a></li><li><a class="tocitem" href="../schedulers/">Scheduling for E-Graph rewriting</a></li><li><a class="tocitem" href="../classic/">Classical Rewriting</a></li><li><a class="tocitem" href="../options/">Global Metatheory.jl Options</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Rules and Theories</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Rules and Theories</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/master/docs/src/theories.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Rules-and-Theories"><a class="docs-heading-anchor" href="#Rules-and-Theories">Rules and Theories</a><a id="Rules-and-Theories-1"></a><a class="docs-heading-anchor-permalink" href="#Rules-and-Theories" title="Permalink"></a></h1><h1 id="Rule-Syntax-for-Classical-Rewriting"><a class="docs-heading-anchor" href="#Rule-Syntax-for-Classical-Rewriting">Rule Syntax for Classical Rewriting</a><a id="Rule-Syntax-for-Classical-Rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Syntax-for-Classical-Rewriting" title="Permalink"></a></h1><table><tr><th style="text-align: right">Kind</th><th style="text-align: right">Supported in Left Hand Side</th><th style="text-align: right">Operator</th><th style="text-align: right">Supported in Right Hand Side</th></tr><tr><td style="text-align: right">Symbolic  Rule</td><td style="text-align: right"><code>x</code>  (pattern variables) <span>$\\$</span> <code>:foo</code> (symbol literals) <span>$\\$</span> <code>x::Type</code> (type assertions) <span>$\\$</span> <code>$(2 + 3)</code> (unquoting) <span>$\\$</span> <code>a...</code> (pattern variable destructuring, matches many subterms as a tuple) <span>$\\$</span>  Other literals are supported.</td><td style="text-align: right"><code>=&gt;</code></td><td style="text-align: right"><code>x</code> (pattern variables) <span>$\\$</span> <code>:foo</code>(symbol literals) <span>$\\$</span> <code>a...</code> (pattern variable destructuring) <span>$\\$</span>  <code>$(2 + 3)</code> (unquoting) <span>$\\$</span> Other literals are supported.</td></tr><tr><td style="text-align: right">Dynamic Rule</td><td style="text-align: right">Same as above</td><td style="text-align: right"><code>|&gt;</code></td><td style="text-align: right">Dynamic rules can execute all valid Julia code. The pattern variables  that matched are available (bound) in the r.h.s.. Other global variables  in the execution module are bound. An additional variable <code>_lhs_expr</code> is bound, referring to the left hand side that matched the rule.</td></tr><tr><td style="text-align: right">Equational Rule</td><td style="text-align: right">Unsupported</td><td style="text-align: right"><code>==</code></td><td style="text-align: right">Unsupported</td></tr></table><h1 id="Rule-Syntax-for-EGraphs-Rewriting"><a class="docs-heading-anchor" href="#Rule-Syntax-for-EGraphs-Rewriting">Rule Syntax for EGraphs Rewriting</a><a id="Rule-Syntax-for-EGraphs-Rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Syntax-for-EGraphs-Rewriting" title="Permalink"></a></h1><table><tr><th style="text-align: right">Kind</th><th style="text-align: right">Supported in  Left Hand Side</th><th style="text-align: right">Operator</th><th style="text-align: right">Supported in Right Hand Side</th></tr><tr><td style="text-align: right">Symbolic  Rule</td><td style="text-align: right"><code>x</code>  (pattern variables) <span>$\\$</span> <code>:foo</code> (symbol literals) <span>$\\$</span> <code>x::Type</code> (type assertions) <span>$\\$</span> <code>$(2 + 3)</code> (unquoting) <span>$\\$</span>  Other literals are supported. <strong>Pattern variable destructuring is not supported</strong>.</td><td style="text-align: right"><code>=&gt;</code></td><td style="text-align: right"><code>x</code> (pattern variables) <span>$\\$</span> <code>:foo</code>(symbol literals) <span>$\\$</span>  <code>$(2 + 3)</code> (unquoting) <span>$\\$</span> Other literals are supported.</td></tr><tr><td style="text-align: right">Dynamic Rule</td><td style="text-align: right">Same as above</td><td style="text-align: right"><code>|&gt;</code></td><td style="text-align: right">Dynamic rules execute valid Julia code. The pattern variables  that matched are available (bound) in the r.h.s.. Other global variables  in the execution module are bound. An additional variable <code>_lhs_expr</code> is bound,  referring to the left hand side that matched the rule.  <strong>NOTE</strong>: additionally, the <code>_egraph</code> variable is bound,  referring to the current <code>EGraph</code> on which rewriting is happening.</td></tr><tr><td style="text-align: right">Equational Rule</td><td style="text-align: right">Same as Symbolic Rules.</td><td style="text-align: right"><code>==</code></td><td style="text-align: right">Same as left hand side of symbolic rules.</td></tr></table><h2 id="Theories-are-Collections-and-Composable"><a class="docs-heading-anchor" href="#Theories-are-Collections-and-Composable">Theories are Collections and Composable</a><a id="Theories-are-Collections-and-Composable-1"></a><a class="docs-heading-anchor-permalink" href="#Theories-are-Collections-and-Composable" title="Permalink"></a></h2><p>Theories are just collections, precisely <em>vectors of the <code>Rule</code> object</em>, and can be composed as regular Julia collections. The most useful way of composing theories is unioning them with the &#39;∪&#39; operator. You are not limited to composing theories, you can manipulate and create them at both runtime and compile time as regular vectors.</p><pre><code class="language-julia">using Metatheory
using Metatheory.EGraphs
using Metatheory.Library

comm_monoid = commutative_monoid(:(*), 1);
comm_group = @theory begin
    a + 0 =&gt; a
    a + b =&gt; b + a
    a + inv(a) =&gt; 0 # inverse
    a + (b + c) =&gt; (a + b) + c
end
distrib = @theory begin
    a * (b + c) =&gt; (a * b) + (a * c)
end
t = comm_monoid ∪ comm_group ∪ distrib</code></pre><pre class="documenter-example-output">9-element Vector{AbstractRule}:
 a * b == b * a
 a * b * c =&gt; a * b * c
 a * b * c =&gt; a * b * c
 1 * a =&gt; a
 a + 0 =&gt; a
 a + b =&gt; b + a
 a + inv(a) =&gt; 0
 a + b + c =&gt; a + b + c
 a * b + c =&gt; a * b + a * c</pre><h2 id="Type-Assertions-and-Dynamic-Rules"><a class="docs-heading-anchor" href="#Type-Assertions-and-Dynamic-Rules">Type Assertions and Dynamic Rules</a><a id="Type-Assertions-and-Dynamic-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Assertions-and-Dynamic-Rules" title="Permalink"></a></h2><p>You can use type assertions in the left hand of rules to match and access literal values both when using classic rewriting and EGraph based rewriting.</p><p>You can also use <strong>dynamic rules</strong>, defined with the <code>|&gt;</code> operator, to dynamically compute values in the right hand of expressions. Dynamic rules, are similar to anonymous functions. Instead of a symbolic substitution, the right hand of a dynamic <code>|&gt;</code> rule is evaluated during rewriting: the values that produced a match are bound to the pattern variables.</p><pre><code class="language-julia">fold_mul = @theory begin
    a::Number * b::Number |&gt; a*b
end
t = comm_monoid ∪ fold_mul
@areequal t (3*4) 12</code></pre><pre class="documenter-example-output">true</pre><h2 id="Escaping"><a class="docs-heading-anchor" href="#Escaping">Escaping</a><a id="Escaping-1"></a><a class="docs-heading-anchor-permalink" href="#Escaping" title="Permalink"></a></h2><p>You can escape values in the left hand side of rules using <code>$</code> just as you would do with the regular <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/">quoting/unquoting</a> mechanism.</p><pre><code class="language-julia">example = @theory begin
    a + $(3+2) |&gt; :something
end</code></pre><pre class="documenter-example-output">1-element Vector{AbstractRule}:
 a + 5 |&gt; :something</pre><h2 id="Patterns"><a class="docs-heading-anchor" href="#Patterns">Patterns</a><a id="Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Patterns" title="Permalink"></a></h2><h2 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.DynamicRule" href="#Metatheory.Rules.DynamicRule"><code>Metatheory.Rules.DynamicRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Rules defined as <code>left_hand |&gt; right_hand</code> are called <code>dynamic</code> rules. Dynamic rules behave like anonymous functions. Instead of a symbolic substitution, the right hand of a dynamic <code>|&gt;</code> rule is evaluated during rewriting: matched values are bound to pattern variables as in a regular function call. This allows for dynamic computation of right hand sides.</p><p>Dynamic rule</p><pre><code class="language-julia">Rule(:(a::Number * b::Number |&gt; a*b))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/028d807b5129c0e2bb97c1cf392e0b6cdc0cecd1/src/Rules/rule_types.jl#L112-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.EqualityRule" href="#Metatheory.Rules.EqualityRule"><code>Metatheory.Rules.EqualityRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Rule(:(a * b == b * a))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/028d807b5129c0e2bb97c1cf392e0b6cdc0cecd1/src/Rules/rule_types.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.RewriteRule" href="#Metatheory.Rules.RewriteRule"><code>Metatheory.Rules.RewriteRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Rules defined as <code>left_hand =&gt; right_hand</code> are called <em>symbolic rewrite</em> rules. Application of a <em>rewrite</em> Rule is a replacement of the <code>left_hand</code> pattern with the <code>right_hand</code> substitution, with the correct instantiation of pattern variables. Function call symbols are not treated as pattern variables, all other identifiers are treated as pattern variables. Literals such as <code>5, :e, &quot;hello&quot;</code> are not treated as pattern variables.</p><pre><code class="language-julia">Rule(:(a * b =&gt; b * a))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/028d807b5129c0e2bb97c1cf392e0b6cdc0cecd1/src/Rules/rule_types.jl#L14-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.UnequalRule" href="#Metatheory.Rules.UnequalRule"><code>Metatheory.Rules.UnequalRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This type of <em>anti</em>-rules is used for checking contradictions in the EGraph backend. If two terms, corresponding to the left and right hand side of an <em>anti-rule</em> are found in an [<code>EGraph</code>], saturation is halted immediately. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/028d807b5129c0e2bb97c1cf392e0b6cdc0cecd1/src/Rules/rule_types.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.Theory" href="#Metatheory.Rules.Theory"><code>Metatheory.Rules.Theory</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Theory is either a vector of <a href="#Metatheory.Rules.Rule"><code>Rule</code></a> or a compiled, callable function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/028d807b5129c0e2bb97c1cf392e0b6cdc0cecd1/src/Rules/rule_dsl.jl#L116-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.Rule" href="#Metatheory.Rules.Rule"><code>Metatheory.Rules.Rule</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct an <code>AbstractRule</code> from a quoted expression. You can also use the [<code>@rule</code>] macro to create a <code>Rule</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/028d807b5129c0e2bb97c1cf392e0b6cdc0cecd1/src/Rules/rule_dsl.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.gettheory-Tuple{Any, Any}" href="#Metatheory.Rules.gettheory-Tuple{Any, Any}"><code>Metatheory.Rules.gettheory</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Retrieve a theory from a module at compile time. TODO cleanup</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/028d807b5129c0e2bb97c1cf392e0b6cdc0cecd1/src/Rules/rule_dsl.jl#L4-L7">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Metatheory.jl</a><a class="docs-footer-nextpage" href="../egraphs/">EGraphs and Equality Saturation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 24 August 2021 14:30">Tuesday 24 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
